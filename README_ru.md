### Подготовленный проект
Данный проект содержит следующие элементы из предметной области "бронирование и распределение комнат в отеле":
- Сущности: Client (клиент), Room (комната), Booking (бронирование, заказ) и RoomReservation (назначение комнаты на заказ).
- Экраны:
  - CRUD экран для Client,
  - CRUD экраны для Room,
  - Экраны для просмотра и создания заказа Booking, а также его отмены.
  - BookingRoomAssignment - экран подбора и назначения комнаты на заказ.
  - ReservedRooms - экран просмотра уже распределенных заказов.
- Spring бин BookingService, содержащий заглушки методов c реализацией бизнес-логики.

### Задание
В данном задании требуется расширить модель данных разнообразными атрибутами, реализовать бизнес-логику, 
операции по поддержанию консистентности данных, а также оптимизировать загружаемые данные в одном из экранов.

#### 1. Валидация модели
Добавьте в модель данных аннотации Bean Validation для автоматического применения следующих ограничений на модель:
- Client
  - email - синтаксически корректный email адрес
  - telephone - строка от 8 до 16 символов
- Room
  - number - число от 100 до 999
  - square meters - положительное число
  - floor - число от 1 до 9

Запустите приложение и проверьте, что редакторы сущностей применяют заданные ограничения при валидации формы. 

#### 2. Добавление черт (Trait) для аудита
- Добавьте в сущность Room черты для выполнения аудита: Audit of creation и Audit of modification.
- Добавьте в таблицу списка комнат (экран RoomBrowse) дополнительные столбцы для отображения новых атрибутов. 
- Перезапустите приложение. Создавайте и изменяйте комнаты в UI, чтобы пронаблюдать, как эти атрибуты заполняются.

#### 3. Вычисляемый неперсистентный атрибут
Добавьте в модель и UI вычисляемый атрибут для показа booking countdown - обратного отсчета в днях до даты заезда клиента.
- Добавьте в сущность Booking вычисляемый атрибут countdownDays *на основе метода*, целое число.
- Реализуйте логику вычисления атрибута - количество дней от текущего момента до времени заезда клиента (arrivalDate).
- Определите для этого атрибута параметр @DependsOnProperties.
- Добавьте новый атрибут как столбец в таблицы экранов BookingBrowse и BookingRoomAssignment.

#### 4. Поддержание целостности данных с помощью события EntitySavingEvent
В сущности Booking присутствует денормализация: атрибуты arrivalDate (дата заезда), nightsOfStay (сколько ночей)
и departureDate (дата отъезда) связаны логически. При этом атрибут departureDate не вводится в интерфейсе создания заказа,
он может вычисляться автоматически (а потом использоваться, например, для эффективной выборки данных из БД по индексу).

- Реализуйте автоматическое вычисление и сохранение атрибута departureDate на основе arrivalDate и nightsOfStay.
- Используйте для этого слушатель события `EntitySavingEvent`.
- Атрибут должен обновляться как при создании, так и при изменении Booking.

#### 5. Составное имя экземпляра (instance name) 
Как вы возможно уже заметили по отображению данных в экранах приложения, у сущности Client не задано имя экземпляра.

Задайте для Client составное имя экземпляра (instance name) следующего формата: "Firstname Lastname",
для информативного отображения в UI приложения.

#### 6. Загрузка данных с помощью EntityManager
Реализуйте метод `com.sample.hotel.app.BookingService#isSuitable()`,
который осуществляет проверку совместимости комнаты с заказом для экрана Room assignment.

Требования к реализации:
- Проверять два условия совместимости:
  - 1) Количество спальных мест в комнате (Room#sleepingPlaces) не должно быть меньше числа гостей (Booking#numberOfGuests).
  - 2) Для выбранной комнаты в БД не должно быть уже назначенных бронирований (RoomReservation),
пересекающихся по сроку пребывания (с arrivalDate по departureDate) с текущим заказом.
Считаем, что клиент может въезжать в комнату в тот же день, когда предыдущий клиент выехал.
- Для загрузки данных нужно использовать интерфейс `javax.persistence.EntityManager`.

Проверить этот метод в работе можно через экран Room assignment (столбец Assign в таблице Rooms).

#### 7. Транзакция для работы с данными
Реализуйте метод `com.sample.hotel.app.BookingService#reserveRoom()`, осуществляющий назначение комнаты на заказ.

- Назначение комнаты на заказ осуществляется путем создания сущности RoomReservation.
- Перед назначением, проверьте *для надежности* совместимость комнаты и заказа еще раз.
- Оберните два действия: проверку и назначение - в транзакцию, чтобы обеспечить изоляцию и атомарность операции.
- Можно использовать декларативную либо программную транзакцию.

Проверить этот метод в работе можно через экран Room assignment (выполнить действие Assign с конкретной комнатой).
Назначенный заказ попадает в экран Reserved rooms.

#### 8. Обновление модели с помощью события EntityChangedEvent
Реализуйте автоматическое освобождение комнаты (Room), если назначенный на нее заказ (Booking) отменяется.
Действие отмены заказа доступно на экране Bookings.

Требования:
- Когда заказ (Booking), уже имеющий назначенную комнату (RoomReservation), меняет свой статус на Cancelled - 
то требуется сразу освободить эту комнату. 
- Для освобождения комнаты нужно просто удалить из БД броню RoomReservation.
- Для реализации используйте слушатель события `EntityChangedEvent`.
- Освобождение должно произойти в той же транзакции, что и смена статуса.

#### 9. Оптимизация фетч-плана в экране и встреча с ошибкой "Cannot get unfetched attribute"
Оптимизируйте объем загружаемых из БД данных в экране Reserved rooms
и научитесь справляться с ошибкой "unfetched attribute" при доступе к незагруженным полям.

Этот экран отображает некоторые данные по RoomReservation и нескольким связанным сущностям.

Фетч план:
- Установите уровень debug для логгера `logging.level.eclipselink.logging.sql`, чтобы видеть SQL запросы к БД в консоли. 
- Отредактируйте fetchPlan контейнера данных, связанного с экраном. Уменьшите количество атрибутов, чтобы
не отображаемые в таблице локальные атрибуты всех загружаемых сущностей (например, Booking#status) не загружались из базы данных.
- Убедитесь по тексту SQL запроса, что количество загружаемых атрибутов сократилось.

Ошибка unfetched attribute:
- Теперь попробуйте вызвать действие "View client email" для одного из отображаемых в таблице заказов.
- Убедитесь в том, что теперь выпадает исключение "unfetched attribute"
(потому что атрибут email отсутствует в *частичном* фетч плане, с которым была загружена сущность Client). 
- Отредактируйте код обработчика действия "View client email" - `ReservedRoomsScreen.onRoomReservationsTableViewClientEmail()`,
чтобы действие продолжало работать, но не добавляя "лишний" атрибут email в фетч-план для загрузки большого списка.
